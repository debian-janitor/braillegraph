#!/usr/bin/perl -w
use strict;
use GD;
use integer;
my ($FILE, $REVERSE, $THRESH) = (undef, 0, 3*128);

while(@ARGV)
{
    $_=shift;
    if (/^-r|--reverse$/) { $REVERSE=1 }
    elsif (/-t|--threshold$/)
    {
        defined($_=shift) and /^(\d+)$/
            or die "-t requires a numeric argument.\n";
        $1<=255 or die "-t must be within 0..255\n";
        $THRESH=$1? $1*3 : 1; # -t 0 allows (0,0,1), -t 1 wants (1,1,1) or (0,0,3)
    }
    elsif (/^-/) { die "Unknown option '$_'.\n" }
    else { $FILE=$_ }
}

my $img = new GD::Image($FILE) or die;
my $sx = $img->width;
my $sy = $img->height;

$sx<=1024 && $sy<=1024
    or die "Sanity check failed: image bigger than 1024x1024.\n";

sub pix($$)
{
    my ($x,$y) = @_;
    my @p = $img->rgb($img->getPixel($x, $y));
    return ($REVERSE xor $p[0]+$p[1]+$p[2]>=$THRESH);
}

sub do_char($$)
{
    my ($x,$y) = @_;
    $x*=2; $y*=4;
    my $g = 0;
    $g+=  1 if pix($x  ,$y  );
    $g+=  8 if pix($x+1,$y  );
    $g+=  2 if pix($x  ,$y+1);
    $g+= 16 if pix($x+1,$y+1);
    $g+=  4 if pix($x  ,$y+2);
    $g+= 32 if pix($x+1,$y+2);
    $g+= 64 if pix($x  ,$y+3);
    $g+=128 if pix($x+1,$y+3);
    # print Unicode codepoint 0x2800+$g, as UTF-8.
    printf("%c%c%c", 0xe2, 0xa0+$g/64, 0x80+$g%64);
}

for my $cy (0..($sy-1)/4)
{
    for my $cx (0..($sx-1)/2)
    {
        do_char($cx, $cy);
    }
    print "\n";
}
